/**
 * Type of the stats reported by each participant (client).
 */
/**
 * The component responsible for the coordination of local recording, across
 * multiple participants.
 * Current implementation requires that there is only one moderator in a room.
 */
export class RecordingController {
    /**
     * For each recording session, there is a separate @{code RecordingAdapter}
     * instance so that encoded bits from the previous sessions can still be
     * retrieved after they ended.
     *
     * @private
     */
    private _adapters;
    /**
     * The {@code JitsiConference} instance.
     *
     * @private
     */
    private _conference;
    /**
     * Current recording session token.
     * Session token is a number generated by the moderator, to ensure every
     * client is in the same recording state.
     *
     * @private
     */
    private _currentSessionToken;
    /**
     * Current state of {@code RecordingController}.
     *
     * @private
     */
    private _state;
    /**
     * Whether or not the audio is muted in the UI. This is stored as internal
     * state of {@code RecordingController} because we might have recording
     * sessions that start muted.
     */
    _isMuted: boolean;
    /**
     * The ID of the active microphone.
     *
     * @private
     */
    private _micDeviceId;
    /**
     * Current recording format. This will be in effect from the next
     * recording session, i.e., if this value is changed during an on-going
     * recording session, that on-going session will not use the new format.
     *
     * @private
     */
    private _format;
    /**
     * Whether or not the {@code RecordingController} has registered for
     * XMPP events. Prevents initialization from happening multiple times.
     *
     * @private
     */
    private _registered;
    /**
     * Registers listeners for XMPP events.
     *
     * @param {JitsiConference} conference - A {@code JitsiConference} instance.
     * @returns {void}
     */
    registerEvents(conference: any): void;
    /**
     * Returns the remote participants' local recording stats.
     *
     * @returns {*}
     */
    getParticipantsStats(): any;
    /**
     * Callback function for XMPP event.
     *
     * @private
     * @param {*} value - The event args.
     * @returns {void}
     */
    private _onStartCommand;
    /**
     * Callback function for XMPP event.
     *
     * @private
     * @param {*} value - The event args.
     * @returns {void}
     */
    private _onStopCommand;
    /**
     * Callback function for XMPP event.
     *
     * @private
     * @returns {void}
     */
    private _onPingCommand;
    /**
     * Starts the recording locally.
     *
     * @private
     * @returns {void}
     */
    private _doStartRecording;
    /**
     * Stops the recording locally.
     *
     * @private
     * @returns {Promise<void>}
     */
    private _doStopRecording;
    /**
     * Sends out updates about the local recording stats via XMPP.
     *
     * @private
     * @returns {void}
     */
    private _updateStats;
    /**
     * Switches to a new local recording session.
     *
     * @param {string} sessionToken - The session Token.
     * @param {string} format - The recording format for the session.
     * @returns {void}
     */
    _switchToNewSession(sessionToken: string, format: string): void;
    /**
     * Sets the event handler for {@code onStateChanged}.
     *
     * @param {Function} delegate - The event handler.
     * @returns {void}
     */
    set onStateChanged(arg: Function);
    _onStateChanged: Function;
    /**
     * Sets the event handler for {@code onNotify}.
     *
     * @param {Function} delegate - The event handler.
     * @returns {void}
     */
    set onNotify(arg: Function);
    _onNotify: Function;
    /**
     * Sets the event handler for {@code onWarning}.
     *
     * @param {Function} delegate - The event handler.
     * @returns {void}
     */
    set onWarning(arg: Function);
    _onWarning: Function;
    /**
     * Signals the participants to start local recording.
     *
     * @returns {void}
     */
    startRecording(format: any): void;
    /**
     * Signals the participants to stop local recording.
     *
     * @returns {void}
     */
    stopRecording(): void;
    /**
     * Triggers the download of recorded data.
     * Browser only.
     *
     * @param {number} sessionToken - The token of the session to download.
     * @returns {void}
     */
    downloadRecordedData(sessionToken: number): void;
    /**
     * Changes the current microphone.
     *
     * @param {string} micDeviceId - The new microphone device ID.
     * @returns {void}
     */
    setMicDevice(micDeviceId: string): void;
    /**
     * Mute or unmute audio. When muted, the ongoing local recording should
     * produce silence.
     *
     * @param {boolean} muted - If the audio should be muted.
     * @returns {void}
     */
    setMuted(muted: boolean): void;
    /**
     * Switches the recording format.
     *
     * @param {string} newFormat - The new format.
     * @returns {void}
     */
    switchFormat(newFormat: string): void;
    /**
     * Returns the local recording stats.
     *
     * @returns {RecordingStats}
     */
    getLocalStats(): any;
    /**
     * Changes the current state of {@code RecordingController}.
     *
     * @private
     * @param {Symbol} newState - The new state.
     * @returns {void}
     */
    private _changeState;
    /**
     * Generates a token that can be used to distinguish each local recording
     * session.
     *
     * @returns {number}
     */
    _getRandomToken(): number;
    /**
     * Creates a recording adapter according to the current recording format.
     *
     * @private
     * @returns {RecordingAdapter}
     */
    private _createRecordingAdapter;
}
