(()=>{"use strict";var e={};function t(e,t,i){return(t=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var i=e[Symbol.toPrimitive];if(void 0!==i){var n=i.call(e,"string");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}e.d=(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);const i="WORKER_LIBFLAC_READY";var n;self.FLAC_SCRIPT_LOCATION="https://sdk.sariska.io/",importScripts("https://sdk.sariska.io/libflac4-1.3.2.min.js");const r={0:"FLAC__STREAM_ENCODER_OK",1:"FLAC__STREAM_ENCODER_UNINITIALIZED",2:"FLAC__STREAM_ENCODER_OGG_ERROR",3:"FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR",4:"FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA",5:"FLAC__STREAM_ENCODER_CLIENT_ERROR",6:"FLAC__STREAM_ENCODER_IO_ERROR",7:"FLAC__STREAM_ENCODER_FRAMING_ERROR",8:"FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR"},o=Object.freeze({UNINTIALIZED:"uninitialized",WORKING:"working",FINISHED:"finished"});class s{constructor(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4096;if(t(this,"_encoderId",0),t(this,"_sampleRate",void 0),t(this,"_bitDepth",void 0),t(this,"_bufferSize",void 0),t(this,"_flacBuffers",[]),t(this,"_flacLength",0),t(this,"_state",o.UNINTIALIZED),t(this,"_data",null),t(this,"_onMetadataAvailable",(()=>{})),!n.isReady())throw new Error("libflac is not ready yet!");if(this._sampleRate=e,this._bitDepth=i,this._bufferSize=r,this._encoderId=n.init_libflac_encoder(this._sampleRate,1,this._bitDepth,5,0,!0,0),0===this._encoderId)throw new Error("Failed to create libflac encoder.");if(0!==n.init_encoder_stream(this._encoderId,this._onEncodedData.bind(this),this._onMetadataAvailable.bind(this)))throw new Error("Failed to initialise libflac encoder.");this._state=o.WORKING}encode(e){if(this._state!==o.WORKING)throw new Error("Encoder is not ready or has finished.");if(!n.isReady())throw new Error("Flac not ready");const t=e.length,i=new Int32Array(t),s=new DataView(i.buffer);let a=0;for(let i=0;i<t;i++)s.setInt32(a,32767*e[i],!0),a+=4;if(1!==n.FLAC__stream_encoder_process_interleaved(this._encoderId,i,i.length)){const e=n.FLAC__stream_encoder_get_state(this._encoderId);console.error("Error during encoding",r[e])}}finish(){if(this._state===o.WORKING){this._state=o.FINISHED;const e=n.FLAC__stream_encoder_finish(this._encoderId);console.log("Flac encoding finished: ",e),n.FLAC__stream_encoder_delete(this._encoderId),this._data=this._exportFlacBlob()}}getBlob(){return this._state===o.FINISHED?this._data:null}_exportFlacBlob(){const e=function(e,t){const i=new Uint8Array(t);let n=0;const r=e.length;for(let t=0;t<r;t++){const r=e[t];i.set(r,n),n+=r.length}return i}(this._flacBuffers,this._flacLength);return new Blob([e],{type:"audio/flac"})}_onEncodedData(e,t){this._flacBuffers.push(e),this._flacLength+=e.byteLength}}let a=null;self.onmessage=function(e){switch(e.data.command){case"MAIN_THREAD_INIT":{const t=e.data.config.bps,r=e.data.config.sampleRate;n.isReady()?(a=new s(r,t),self.postMessage({command:i})):n.onready=function(){setTimeout((()=>{a=new s(r,t),self.postMessage({command:i})}),0)};break}case"MAIN_THREAD_NEW_DATA_ARRIVED":null===a?console.error("flacEncoderWorker received data when the encoder is not ready."):a.encode(e.data.buf);break;case"MAIN_THREAD_FINISH":if(null!==a){a.finish();const e=a.getBlob();self.postMessage({command:"WORKER_BLOB_READY",buf:e}),a=null}}}})();
//# sourceMappingURL=flacEncodeWorker.min.map